# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1siD0LpMniX174eFSic4C8fPy6-ytiXTK
"""

# ============================================================
# SkyHigh Hotels ‚Äî Hybrid Dynamic Pricing
# Prophet (Time Series) + Multi-Model ML
# WITHOUT Competitor Pricing
# ============================================================

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import io

from prophet import Prophet
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor, HistGradientBoostingRegressor
from sklearn.linear_model import LinearRegression

# ------------------------------------------------------------
# STREAMLIT CONFIG
# ------------------------------------------------------------
st.set_page_config(layout="wide", page_title="Hybrid Dynamic Pricing (No Competitor Pricing)")
st.title("üè® SkyHigh Hotels ‚Äî Hybrid Dynamic Pricing")
st.caption("Prophet (Demand Forecasting) + Machine Learning (Price Sensitivity)")

# ------------------------------------------------------------
# 1Ô∏è‚É£ DATA LOAD / SYNTHETIC FALLBACK
# ------------------------------------------------------------
st.sidebar.header("1) Data")
uploaded = st.sidebar.file_uploader(
    "Upload CSV or Excel (must contain stay_date, price, bookings)",
    type=["csv", "xlsx"]
)

def safe_read(u):
    try:
        if u.name.lower().endswith(".csv"):
            return pd.read_csv(u)
        else:
            return pd.read_excel(u)
    except Exception:
        return None

if uploaded:
    df = safe_read(uploaded)
    if df is None or "stay_date" not in df.columns:
        st.error("Invalid file. Using synthetic dataset instead.")
        uploaded = None
    else:
        df["stay_date"] = pd.to_datetime(df["stay_date"])

if not uploaded:
    st.sidebar.info("No file uploaded ‚Äî using synthetic example data.")
    rng = pd.date_range("2025-01-01", "2025-12-31", freq="D")
    rows = []
    rs = np.random.RandomState(42)

    for d in rng:
        for rt in ["Standard", "Deluxe"]:
            base = 20 if rt == "Standard" else 12
            weekend = d.weekday() >= 5
            event_flag = int(d.day % 15 == 0)

            median_price = 300 if rt == "Standard" else 500
            price = median_price + rs.randint(-60, 80)
            days_to_stay = rs.randint(0, 60)

            demand = (
                base
                + 6 * weekend
                + 12 * event_flag
                - 0.02 * (price - median_price)
            ) * np.exp(-0.02 * days_to_stay)

            bookings = max(0, int(demand + rs.normal(0, 2)))

            rows.append({
                "stay_date": d,
                "room_type": rt,
                "price": price,
                "days_to_stay": days_to_stay,
                "event_flag": event_flag,
                "bookings": bookings
            })

    df = pd.DataFrame(rows)

st.subheader("Sample historical data")
st.dataframe(df.head(6))

# ------------------------------------------------------------
# 2Ô∏è‚É£ PROPHET ‚Äî BASELINE DEMAND
# ------------------------------------------------------------
@st.cache_resource
def train_prophet(df):
    ts = df.groupby("stay_date")["bookings"].sum().reset_index()
    ts.columns = ["ds", "y"]

    model = Prophet(
        yearly_seasonality=True,
        weekly_seasonality=True,
        daily_seasonality=False
    )
    model.fit(ts)
    return model, ts

prophet_model, ts_data = train_prophet(df)

def prophet_baseline(date):
    future = pd.DataFrame({"ds": [pd.to_datetime(date)]})
    forecast = prophet_model.predict(future)
    return max(0, forecast["yhat"].iloc[0])

# ------------------------------------------------------------
# 3Ô∏è‚É£ FEATURE ENGINEERING (NO COMPETITOR FEATURES)
# ------------------------------------------------------------
def featurize_for_training(df_in):
    X = df_in.copy()
    X["day_of_week"] = X["stay_date"].dt.weekday
    X["is_weekend"] = X["day_of_week"].isin([5, 6]).astype(int)
    X["month"] = X["stay_date"].dt.month

    dummies = pd.get_dummies(X["room_type"], prefix="room_type")
    for c in ["room_type_Standard", "room_type_Deluxe"]:
        if c not in dummies.columns:
            dummies[c] = 0

    X = pd.concat([X, dummies[["room_type_Standard", "room_type_Deluxe"]]], axis=1)

    features = [
        "price", "days_to_stay", "event_flag",
        "is_weekend", "month",
        "room_type_Standard", "room_type_Deluxe"
    ]

    return X[features], df_in["bookings"].values

def featurize_for_candidates(df_cand, cols):
    Xc, _ = featurize_for_training(df_cand.assign(bookings=0))
    for c in cols:
        if c not in Xc.columns:
            Xc[c] = 0
    return Xc[cols]

X_all, y_all = featurize_for_training(df)

# ------------------------------------------------------------
# 4Ô∏è‚É£ MULTI-MODEL TRAINING & SELECTION
# ------------------------------------------------------------
st.sidebar.header("2) Model training & selection")
test_frac = st.sidebar.slider("Test fraction", 0.05, 0.4, 0.2, step=0.05)
retrain_btn = st.sidebar.button("Train & evaluate models")

models = {
    "RandomForest": RandomForestRegressor(n_estimators=150, random_state=42),
    "GradientBoosting": GradientBoostingRegressor(n_estimators=200, learning_rate=0.05),
    "HistGradientBoosting": HistGradientBoostingRegressor(max_iter=200),
    "LinearRegression": LinearRegression()
}

if retrain_btn or "best_model" not in st.session_state:
    X_train, X_test, y_train, y_test = train_test_split(
        X_all, y_all, test_size=test_frac, random_state=42
    )

    perf = {}
    trained = {}

    for name, model in models.items():
        model.fit(X_train, y_train)
        preds = np.clip(model.predict(X_test), 0, None)
        mae = mean_absolute_error(y_test, preds)
        perf[name] = mae
        trained[name] = model

    best_name = min(perf, key=perf.get)

    st.session_state["best_model"] = trained[best_name]
    st.session_state["best_model_name"] = best_name
    st.session_state["model_perf"] = perf
    st.session_state["feature_cols"] = X_all.columns.tolist()
    st.session_state["hist_avg"] = y_all.mean()

st.subheader("Model Performance (MAE)")
perf_df = pd.DataFrame(
    st.session_state["model_perf"].items(),
    columns=["Model", "MAE"]
)
st.dataframe(perf_df.sort_values("MAE"))

# ------------------------------------------------------------
# 5Ô∏è‚É£ PRICING SCENARIO
# ------------------------------------------------------------
st.sidebar.header("3) Pricing Scenario")
stay_date = st.sidebar.date_input("Stay date", pd.to_datetime("2025-06-15"))
room_type = st.sidebar.selectbox("Room type", ["Standard", "Deluxe"])
days_to_stay = st.sidebar.number_input("Lead time (days)", 0, 60, 10)
event_flag = st.sidebar.checkbox("Event")

median_price = 300 if room_type == "Standard" else 500
min_price = st.sidebar.number_input("Min price", int(median_price * 0.6))
max_price = st.sidebar.number_input("Max price", int(median_price * 1.6))
step = st.sidebar.number_input("Price step", 10)

prices = list(range(min_price, max_price + 1, step))

cand_rows = []
for p in prices:
    cand_rows.append({
        "stay_date": pd.to_datetime(stay_date),
        "room_type": room_type,
        "price": p,
        "days_to_stay": days_to_stay,
        "event_flag": int(event_flag)
    })

candidates_raw = pd.DataFrame(cand_rows)

# ------------------------------------------------------------
# 6Ô∏è‚É£ HYBRID DEMAND & OPTIMIZATION
# ------------------------------------------------------------
X_cand = featurize_for_candidates(
    candidates_raw,
    st.session_state["feature_cols"]
)

baseline = prophet_baseline(stay_date)

ml_preds = np.clip(
    st.session_state["best_model"].predict(X_cand), 0, None
)

multiplier = ml_preds / st.session_state["hist_avg"]
final_demand = np.clip(baseline * multiplier, 0, None)

candidates_raw["predicted_bookings"] = final_demand
candidates_raw["expected_revenue"] = candidates_raw["price"] * final_demand

best_row = candidates_raw.loc[
    candidates_raw["expected_revenue"].idxmax()
]

# ------------------------------------------------------------
# 7Ô∏è‚É£ OUTPUT & DOWNLOADS
# ------------------------------------------------------------
st.header("üí° Recommendation")

st.metric("Baseline Demand (Prophet)", f"{baseline:.1f}")
st.metric("Selected ML Model", st.session_state["best_model_name"])
st.metric("Recommended Price", f"‚Çπ {int(best_row['price'])}")
st.metric("Expected Revenue", f"‚Çπ {best_row['expected_revenue']:.2f}")

st.subheader("Top Price Options")
st.dataframe(
    candidates_raw.sort_values("expected_revenue", ascending=False).head(10)
)

# Plot
fig, ax1 = plt.subplots(figsize=(10, 5))
ax1.plot(candidates_raw["price"], candidates_raw["expected_revenue"], marker="o")
ax1.set_xlabel("Price")
ax1.set_ylabel("Expected Revenue")
ax1.grid(True)

ax2 = ax1.twinx()
ax2.plot(
    candidates_raw["price"],
    candidates_raw["predicted_bookings"],
    linestyle="--",
    marker="x",
    color="orange"
)
ax2.set_ylabel("Predicted Bookings")

st.pyplot(fig)

# Downloads
buf = io.BytesIO()
fig.savefig(buf, format="png", dpi=150)
buf.seek(0)
st.download_button("Download chart (PNG)", buf, "price_vs_revenue.png", "image/png")

st.download_button(
    "Download candidate table (CSV)",
    candidates_raw.to_csv(index=False).encode(),
    "candidates.csv",
    "text/csv"
)

# ------------------------------------------------------------
# END
# ------------------------------------------------------------